<?php

/**
 * Oracle OCI Connector
 *
 * This file supports Oracle OCI using the native oci extension:
 * http://php.net/manual/en/book.oci8.php
 *
 * PHP versions 4 and 5
 *
 * Licensed under The MIT License
 */
App::uses('DboSource', 'Model/Datasource');

/**
 * Oracle OCI8 Connector
 *
 * This file supports Oracle OCI8 using the native oci8 extension:
 * http://php.net/manual/en/book.oci8.php
 */
class Oci extends DboSource {

    /**
     * A short description of the type of driver.
     * 
     * @var string
     */
    public $description = 'Oracle OCI Driver';

    /**
     * The start quote in which database column and table names should be wrapped.
     * 
     * @var string
     */
    public $startQuote = '';

    /**
     * The end quote in which database column and table names should be wrapped.
     * 
     * @var string
     */
    public $endQuote = '';

    /**
     * Oracle just uses a space for table aliases.
     * 
     * @var string
     */
    public $alias = ' ';

    /**
     * An array of base configuration settings to be used if settings are not
     * provided, i.e. default host, port, and connection method.
     * 
     * @var array
     */
    protected $_baseConfig = array(
        'persistent' => true,
        'login' => 'oracleinst1',
        'password' => '',
        'sid' => '',
        'database' => '',
        'schema' => '',
        'hostname' => '127.0.0.1',
        'port' => '1521',
        'encoding' => true,
        'autocommit' => true,
        'driver_version' => 8
    );

    /**
     * An array that maps Cake column types to database native column types.
     * The mapped information can include a reference to a function that should
     * be used to format the data, as well as a string that defines the
     * formatting according to that function.
     * 
     * @var array
     */
    public $columns = array(
        'primary_key' => array('name' => 'not null generated by default as identity (start with 1, increment by 1)'),
        'string' => array('name' => 'varchar2', 'limit' => '255'),
        'text' => array('name' => 'clob'),
        'integer' => array('name' => 'number', 'limit' => '10', 'formatter' => 'intval'),
        'float' => array('name' => 'number', 'formatter' => 'floatval'),
        'datetime' => array('name' => 'date', 'format' => 'DD-MON-YY HH:MI:SS', 'formatter' => 'date'),
        'timestamp' => array('name' => 'date', 'format' => 'DD-MON-YY HH:MI:SS', 'formatter' => 'date'),
        'time' => array('name' => 'date', 'format' => 'HH:MI:SS', 'formatter' => 'date'),
        'date' => array('name' => 'date', 'format' => 'DD-MON-YY', 'formatter' => 'date'),
        'binary' => array('name' => 'blob'),
        'boolean' => array('name' => 'number', 'limit' => '1')
    );

    /**
     * A map for every result mapping tables to columns
     * 
     * @var array result -> ( table -> column )
     */
    protected $_resultMap = array();

    /**
     * The OCI8 connector is rough so we will need to dump the data to an array.
     * Not very lazy but it works.
     * 
     * @var array
     */
    protected $_rawResults = array();

    /**
     * Current row being asked for.
     * 
     * @var int 
     */
    private $currentRow = 0;

    /**
     * Connects to the database using options in the given configuration array.
     * 
     * @return boolean True if the database could be connected, else false
     */
    public function connect() {
        $config = $this->config;
        $connect = 'oci_connect';
        if ($config['persistent']) {
            $connect = 'oci_pconnect';
        }
        $this->connected = false;
        $this->connection = $connect($config['login'], $config['password'], $config['host'] . ':' . $config['port'] . '/' . $config['sid']);
        if ($this->connection) {
            $this->connected = true;
        }
        if ($config['schema'] !== '') {
            $this->setCurrentSchema();
        }
        return $this->connected;
    }

    /**
     * Set the current schema
     */
    public function setCurrentSchema() {
        $schema = $this->config['schema'];
        $this->_execute("ALTER SESSION SET CURRENT_SCHEMA = $schema");
    }

    /**
     * Check that the OCI* extension is installed/loaded
     * 
     * @return boolean
     */
    public function enabled() {
        return extension_loaded('oci'.$this->config['driver_version']);
    }

    /**
     * Disconnects from database.
     *
     * @return boolean True if the database could be disconnected, else false
     */
    public function disconnect() {
        oci_free_statement($this->results);
        $this->connected = !oci_close($this->connection);
        return !$this->connected;
    }

    /**
     * Executes given SQL statement.
     *
     * @param string $sql SQL statement
     * @return resource Result resource identifier
     */
    protected function _execute($sql, $params = array(), $prepareOptions = array()) {
        $stid = oci_parse($this->connection, $sql);
        oci_execute($stid);
        return $stid;
    }

    /**
     * Returns an array of all the tables in the database.
     * Should call parent::listSources twice in the method:
     * once to see if the list is cached, and once to cache
     * the list if not.
     *
     * @return array of tablenames in the database
     */
    public function listSources($data = null) {
        $cache = parent::listSources($data);
        if ($cache != null) {
            return $cache;
        }
        $tables = array();
        $schema = $this->config['schema'];
        $resource = $this->_execute("SELECT owner, table_name FROM all_tables WHERE owner = '$schema'");
        while (($entry = oci_fetch_array($resource, OCI_ASSOC + OCI_RETURN_NULLS)) != false) {
            $tables[] = strtolower($entry['TABLE_NAME']);
        }
        parent::listSources($tables);
        return $tables;
    }

    /**
     * Returns an array of the fields for a given table name.
     *
     * @param Model $model Model object to describe
     * @return array of fields in table. Keys are name and type
     */
    public function describe($model) {
        $cache = parent::describe($model);
        if ($cache != null) {
            return $cache;
        }
        $fields = array();
        $table = strtoupper($this->fullTableName($model));
        $resource = $this->_execute("select * from all_tab_columns where table_name = '$table'");
        while (($entry = oci_fetch_array($resource, OCI_ASSOC + OCI_RETURN_NULLS)) != false) {
            $fields[strtolower($entry['COLUMN_NAME'])] = array(
                'type' => $this->column(strtolower($entry['DATA_TYPE'])),
                'null' => $entry['NULLABLE'],
                'default' => $entry['DATA_DEFAULT'],
                'length' => $entry['DATA_LENGTH']
            );
        }
        $this->_cacheDescription($model->tablePrefix . $model->table, $fields);
        return $fields;
    }

    /**
     * Returns a quoted and escaped string of $data for use in an SQL statement.
     *
     * @param string $data String to be prepared for use in an SQL statement
     * @param string $column The column into which this data will be inserted
     * @return string Quoted and escaped
     * @todo Add logic that formats/escapes data based on column type
     */
    public function value($data, $column = null, $safe = false) {
        if ($data === null || (is_array($data) && empty($data))) {
            return 'NULL';
        }
        if ($data === '') {
            return "''";
        }
        switch ($column) {
            case 'boolean':
                $data = $this->boolean((bool) $data);
                break;
            case 'integer':
                $data = intval($data);
                break;
            default:
                $data = str_replace("'", "''", $data);
                break;
        }
        if ($column === 'integer' || $column === 'float') {
            return $data;
        }
        return "'" . $data . "'";
    }

    /**
     * Translates between PHP boolean values and Oracle (faked) boolean values
     *
     * @param mixed $data Value to be translated
     * @return mixed Converted boolean value
     */
    public function boolean($data, $quote = false) {
        if ($data === true || $data === false) {
            if ($data === true) {
                return 1;
            }
            return 0;
        } else {
            if (intval($data !== 0)) {
                return true;
            }
            return false;
        }
    }

    /**
     * Begins a transaction.  Returns true if the transaction was
     * started successfully, otherwise false.
     *
     * @return boolean True on success, false on fail
     * (i.e. if the database/model does not support transactions).
     */
    public function begin() {
        if (parent::begin()) {
            $this->_transactionStarted = true;
            return true;
        }
        return false;
    }

    /**
     * Commit a transaction
     *
     * @return boolean True on success, false on fail
     * (i.e. if the database/model does not support transactions,
     * or a transaction has not started).
     */
    public function commit() {
        if (parent::commit()) {
            if (oci_commit($this->connection)) {
                $this->_transactionStarted = false;
                return true;
            }
        }
        return false;
    }

    /**
     * Rollback a transaction
     *
     * @return boolean True on success, false on fail
     * (i.e. if the database/model does not support transactions,
     * or a transaction has not started).
     */
    public function rollback() {
        if (parent::rollback()) {
            $this->_transactionStarted = false;
            return oci_rollback($this->connection);
        }
        return false;
    }

    /**
     * Removes Identity (primary key) column from update data before returning to parent.
     * So the primary key is never updated.
     *
     * @param Model $model The model to update.
     * @param array $fields The fields to update
     * @param array $values The values fo the fields.
     * @param mixed $conditions The conditions for the update. When non-empty $values will not be quoted.
     * @return bool Success
     */
    public function update(Model $model, $fields = array(), $values = null, $conditions = null) {
        foreach ($fields as $i => $field) {
            if ($field == $model->primaryKey) {
                unset($fields[$i]);
                unset($values[$i]);
                break;
            }
        }
        return parent::update($model, $fields, $values, $conditions);
    }

    /**
     * Returns a formatted error message from previous database operation.
     * 
     * @return string Error message with error number
     */
    public function lastError(PDOStatement $query = null) {
        if (oci_error()) {
            return oci_error() . ': ' . db2_stmt_errormsg();
        }
        return null;
    }

    /**
     * Returns number of affected rows in previous database operation. If no 
     * previous operation exists, this returns false.
     *
     * @param oci resource $source
     * @return integer Number of affected rows
     */
    public function lastAffected($source = null) {
        if ($this->_result) {
            $this->setRawResults();
            $count = sizeof($this->_rawResults);
            return $count;
        }
        return null;
    }

    /**
     * Load the raw results if the are empty.
     */
    private function setRawResults() {
        if ($this->_result && empty($this->_rawResults)) {
            while (($entry = oci_fetch_array($this->_result, OCI_ASSOC + OCI_RETURN_NULLS)) != false) {
                $this->_rawResults[] = $entry;
            }
        }
    }

    /**
     * Returns number of rows in previous resultset. If no previous resultset exists,
     * this returns false.
     *
     * @param oci resource $source
     * @return integer Number of rows in resultset
     */
    public function lastNumRows($source = null) {
        return $this->lastAffected($source);
    }

    /**
     * Returns the ID generated from the previous INSERT operation.
     * This assumes the primary id is 'id', not good but this callback
     * doesn't give me access to the model.
     *
     * @param oci resource $source
     * @return int or null
     */
    public function lastInsertId($source = null) {
        if ($this->_rawResults && isset($this->_rawResults[0]['id'])) {
            return $this->_rawResults[0]['id'];
        }
        return null;
    }

    /**
     * Returns a limit statement in the correct format for the particular database.
     *
     * @param integer $limit Limit of results returned
     * @param integer $offset Offset from which to start results
     * @return string SQL limit/offset statement
     */
    public function limit($limit, $offset = null) {
        if ($limit) {
            $rt = '';
            if (!strpos(strtolower($limit), 'rownum') || strpos(strtolower($limit), 'rownum') === 0) {
                $rt = sprintf('ROWNUM =< %d AND ROWNUM > %d', $offset, ($limit + $offset));
            }
            pr($rt);
            return $rt;
        }
        return null;
    }

    /**
     * Converts database-layer column types to basic types
     *
     * @param string $real Real database-layer column type (i.e. "varchar(255)")
     * @return string Abstract column type (i.e. "string")
     */
    public function column($real) {
        $limit = null;
        if (strpos($real, '(') !== false) {
            list($real, $limit) = explode('(', $real);
        }
        if (in_array($real, array('date', 'time', 'datetime', 'timestamp'))) {
            return $real;
        }
        if (in_array($real, array('number', 'bigint', 'smallint', 'tinyint'))) {
            return 'integer';
        }
        if (strpos($real, 'char') !== false) {
            return 'string';
        }
        if (strpos($real, 'blob') !== false || $real === 'image') {
            return 'binary';
        }
        if (in_array($real, array('double', 'real', 'decimal'))) {
            return 'float';
        }
        return 'text';
    }

    /**
     * Maps a result set to an array so that returned fields are
     * grouped by model.  Any calculated fields, or fields that
     * do not correspond to a particular model belong under array
     * key 0.
     * 
     * @param oci resource $results
     */
    public function resultSet($results) {
        $this->currentRow = 0;
        $this->map = array();
        $table = '';
        foreach ($this->_descriptions as $tableName => $description) {
            $table = Inflector::classify($tableName);
            break;
        }
        foreach ($this->_rawResults as $key => $row) {
            foreach ($row as $field => $value) {
                $this->map[] = array($table, strtolower($field));
            }
            break;
        }
    }

    /**
     * Checks to see if the raw results array has more than one entry.
     * Note: oci_num_rows returns affect rows which seems to be useless on
     * selects.
     * 
     * @return boolean 
     */
    public function hasResult() {
        return $this->lastAffected() > 0;
    }

    /**
     * Fetches the next row from the current result set
     * Maps the records in the $result property to the map
     * created in resultSet().
     *
     * @return array
     */
    public function fetchResult() {
        if (isset($this->_rawResults[$this->currentRow])) {
            $row = $this->_rawResults[$this->currentRow];
            $resultRow = array();
            foreach ($this->map as $meta) {
                list($table, $column) = $meta;
                $resultRow[$table][$column] = $row[strtoupper($column)];
            }
            $this->currentRow++;
            return $resultRow;
        }
        return false;
    }

}
